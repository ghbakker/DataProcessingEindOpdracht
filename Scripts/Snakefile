configfile: "../config.yaml"
workdir: "../TempFiles/"

# Sort Bam
rule all:
    input:
        "../Results/.pdf"
        #expand("zipped_vcf/{sample}.vcf.gz" , sample = config['Samples'])
        #expand("variants/{sample}.vcf", sample = config['TestSamples'])

rule bam_sort:
    input:
        config['DataPath'] + "{sample}.bam"
    output:
        "sorted_read/{sample}.bam"
    threads: config["Threads"]
    log: "log/bamsort/{sample}.log"
    shell:
        "samtools sort {input} > {output} --threads {threads} 2> {log}"

rule index_bam:
    input:
        "sorted_read/{sample}.bam"
    output:
        "sorted_read/{sample}.bam.bai"
    threads: config["Threads"]
    log: "log/bamsort/{sample}.bai.log"
    shell:
        "samtools index {input} 2> {log}"

# Obtaining the Mouse Reference Genome
rule convert2bit:
    input:
        func="../BashPipelineScripts/twoBitToFa",
        data=config['DataPath'] + "mm10.2bit"
    output:
        config['DataPath'] + "mm10.fa"
    log: "log/twoBitWoFa/mm10.fa.log"
    shell:
        "{input.func} {input.data} {output} 2> {log}"

rule index_fa:
    input:
        config['DataPath'] + "mm10.fa"
    output:
        config['DataPath'] + "mm10.fa.fai"
    log: "log/twoBitWoFa/mm10.fa.fai.log"
    shell:
        "samtools faidx {input} 2> {log}"

# Variant Calling
# need to get and convert human and mouse genome for the following rules. But Disc Quota.
rule variant_calling:
    input:
        ref=config['DataPath'] + "mm10.fa",
        fai=config['DataPath'] + "mm10.fa.fai",
        bam="sorted_read/{sample}.bam",
        bai="sorted_read/{sample}.bam.bai" #not necessary?
    output:
        "variants/{sample}.vcf"
    message:
        "Performing Variant Calling with freebayes for the following bam files: {input.bam}"
    threads: config["Threads"]
    log: "log/variant_calling/{sample}.log"
    shell:
        "freebayes-parallel <(fasta_generate_regions.py {input.fai} 100000) {threads} -f {input.ref} -b {input.bam} > {output} 2> {log}"

# Filtering Combined Mouse (Make use of temporary files?)
rule filter:
    input:
        "variants/{sample}.vcf"
    output:
        "vcf_filter/{sample}_QUAL.vcf"
    log: "log/filter/{sample}.log"
    shell:
        'vcffilter -f "QUAL > 30"  {input} > {output} 2> {log}'

rule DP_filter:
    input:
        "vcf_filter/{sample}_QUAL.vcf"
    output:
        "vcf_filter/{sample}_DP.vcf"
    log: "log/DP_filter/{sample}.log"
    shell:
        'vcffilter -f "DP > 10" {input} > {output} 2> {log}'

rule decompose:
    input:
        "vcf_filter/{sample}_DP.vcf"
    output:
        "vcf_outputs/{sample}_decomposed.vcf"
    log: "log/decompose/{sample}.log"
    shell:
        "vcfallelicprimitives -g {input} > {output} 2> {log}"

# In Bash this uses two different flows seperated by the if statements.
rule intersect_vcf:
    input:
        "vcf_outputs/{sample}_decomposed.vcf"
    output:
        "vcf_outputs/{sample}_decomposed.vcf.gz"
    log: "log/intersect_vcf/{sample}.log"
    shell:
        "bgzip -i {input} 2> {log}"

rule BGZIP:
    input:
        "vcf_outputs/{sample}_decomposed.vcf.gz"
    output:
        "zipped_vcf/{sample}.vcf.gz"
    log: "log/BGZIP/{sample}.log"
    shell:
        "zcat {input} | bgzip -c > {output} 2> {log}"

### Genotypes Variants Mouse.sh
## Start with WT:

# bcftools isec -n =$(ls -1 WT*.filtered.vcf.gz.new.gz | wc -l ) WT*.filtered.vcf.gz.new.gz > WT.sites.vcf
rule WT_bcf_intersect:
    input:
        "zipped_vcf/WT.vcf.gz"
    output:
        "zipped_vcf/WT.sites.vcf"
    log: "log/WT_cf_intersect/WT.sites.log"
    shell:
        "bcftools isec -n =$(ls -1 {input} | wc -l ) {input} > {output} 2> {log}"

# TODO maybe bgzip -d WT1.filtered.vcf.gz is needed

# grep "#" WT1.filtered.vcf > header.vcf
rule WT_header:
    input:
        "vcf_outputs/WT_decomposed.vcf"
    output:
        "WT_header.vcf"
    log: "log/WT_header/WT_header.log"
    shell:
        'grep "#" {input} > {output} 2> {log}'

#awk 'FILENAME == "WT.sites.vcf" { remember[$1 $2]=1 ;}
#     FILENAME != "WT.sites.vcf" { if ( $1 $2 in remember ) print ; } ' WT.sites.vcf WT1.filtered.vcf > WT_1.vcf
rule WT1_awk:
    input:
        sites="zipped_vcf/WT.sites.vcf",
        filtered="vcf_outputs/WT_decomposed.vcf"
    output:
        "WT_1.vcf"
    log: "log/WT1_awk/WT_1.log"
    shell:
        "awk \'FILENAME == \"{input.sites}\" {{ remember[$1 $2]=1 ;}}"
        "FILENAME != \"{input.sites}\" {{ if ( $1 $2 in remember ) print ; }} \' {input.sites} {input.filtered} > {output} 2> {log}"

# cat header.vcf WT_1.vcf > WT.intersection.vcf
rule WT1_cat:
    input:
        WT="WT_1.vcf",
        header="WT_header.vcf"
    output:
        "WT.intersection.vcf"
    log: "log/WT1_cat/WT.intersection.log"
    shell:
        "cat {input.header} {input.WT} > {output} 2> {log}"

## Combine KO's
# bcftools isec -n =$(ls -1 KO*.filtered.vcf.gz.new.gz | wc -l ) KO*.filtered.vcf.gz.new.gz > KO.sites.vcf
rule KO_bcf_intersect:
    input:
        KO1="zipped_vcf/KO1.vcf.gz",
        KO2="zipped_vcf/KO2.vcf.gz",
        KO3="zipped_vcf/KO3.vcf.gz"
    output:
        "zipped_vcf/KO.sites.vcf"
    log: "log/KO_bcf_intersect/KO.sites.log"
    shell:
        "bcftools isec -n =$(ls -1 {input.KO1} {input.KO2} {input.KO3}| wc -l ) {input.KO1} {input.KO2} {input.KO3} > {output} 2> {log}"

# grep "#" KO1.filtered.vcf > header.vcf
rule KO_header:
    input:
        "vcf_outputs/KO1_decomposed.vcf"
    output:
        "KO_header.vcf"
    log: "log/KO_header/KO_header.log"
    shell:
        'grep "#" {input} > {output} 2> {log}'

# awk 'FILENAME == "KO.sites.vcf" { remember[$1 $2]=1 ;}
#     FILENAME != "KO.sites.vcf" { if ( $1 $2 in remember ) print ; } ' KO.sites.vcf KO1.filtered.vcf > KO_1.vcf
rule KO_awk:
    input:
        sites="zipped_vcf/KO.sites.vcf",
        filtered="vcf_outputs/KO1_decomposed.vcf"
    output:
        "KO_1.vcf"
    log: "log/KO_awk/KO_1.log"
    shell:
        "awk \'FILENAME == \"{input.sites}\" {{ remember[$1 $2]=1 ;}}"
        "FILENAME != \"{input.sites}\" {{ if ( $1 $2 in remember ) print ; }} \' {input.sites} {input.filtered} > {output} 2> {log}"


# cat header.vcf KO_1.vcf > KO.intersection.vcf
rule KO_cat:
    input:
        KO="KO_1.vcf",
        header="KO_header.vcf"
    output:
        "KO.intersection.vcf"
    log: "log/KO_cat/KO.intersect.log"
    shell:
        "cat {input.header} {input.WT} > {output} 2> {log}"


# Visualization
## TODO combine de KO's
rule visualize:
    input:
        WT = "WT.intersection.vcf",
        KO = "KO.intersection.vcf"
    output:
        "../Results/.pdf"
    log: "log/visualize/results.log"
    shell:
        "Rscript ../Scripts/genotype_variants_mouse_linux.R {input.WT} {input.KO} {output} 2> {log}"

# Clean Files
rule clean:
    shell:
        "rm -f -r sorted_read/ log/"

# dag
rule dag:
    shell:
        "snakemake --forceall --dag | dot -Tpng > dag.png"
